# ğŸ§ª Prompt de Teste UnitÃ¡rio - CoCoT Precision

## ğŸ¯ OBJETIVO
Testar a funÃ§Ã£o `[NOME_DA_FUNÃ‡ÃƒO]` do mÃ³dulo `[CAMINHO/ARQUIVO]` assegurando:
- Comportamento determinÃ­stico
- Tratamento de exceÃ§Ãµes
- Cobertura total de lÃ³gica, bordas e falhas
- ValidaÃ§Ã£o de performance (quando aplicÃ¡vel)
- Contrato de interface (se aplicÃ¡vel)
- Isolamento via fixture (ambiente controlado)
- Zero dependÃªncias externas reais

---

## âœ… CENÃRIOS A COBRIR

### 1. ğŸ§® Teste DeterminÃ­stico
```python
def test_[nome]_[resultado_esperado]():
    # Arrange
    instancia = [Classe]()
    
    # Act
    resultado = instancia.[mÃ©todo](entrada_padrao)
    
    # Assert
    assert resultado == resultado_esperado
```

### 2. âŒ Teste de ExceÃ§Ã£o
```python
def test_[nome]_raises_exception_on_invalid_input():
    instancia = [Classe]()

    with pytest.raises([ExcecaoEsperada]) as excinfo:
        instancia.[mÃ©todo](entrada_invalida)

    assert "mensagem esperada" in str(excinfo.value)
```

### 3. âš¡ Teste de Performance UnitÃ¡ria
```python
def test_[nome]_performance_below_threshold():
    inicio = time.perf_counter()
    resultado = [mÃ©todo](param)
    duracao = time.perf_counter() - inicio

    assert resultado == esperado
    assert duracao < limite_em_segundos
```

### 4. ğŸ“ Teste Baseado em Propriedade (Hypothesis)
```python
@given(st.integers(), st.integers())
def test_[nome]_satisfies_commutative_property(a, b):
    assert [funÃ§Ã£o](a, b) == [funÃ§Ã£o](b, a)
```

### 5. ğŸ§¼ Teste de NormalizaÃ§Ã£o de Dados
```python
def test_[nome]_normaliza_dados_corretamente():
    entrada = {"Nome": " JoÃ£o ", "Idade": "30"}
    esperado = {"nome": "joÃ£o", "idade": 30}
    
    assert [classe]().normalizar(entrada) == esperado
```

### 6. ğŸ“‹ Teste de Contrato de Interface
```python
def test_[classe]_implements_interface():
    repo = [classe]()
    assert hasattr(repo, "save")
    assert hasattr(repo, "delete")

    usuario = User(id=1, name="Teste")
    repo.save(usuario)
    assert repo.find_by_id(1) == usuario
```

### 7. ğŸ§ª Isolamento via Fixture
```python
@pytest.fixture
def ambiente_controlado():
    db = MockDatabase()
    sistema = Sistema(db=db)
    yield sistema
    db.reset()

def test_[nome]_com_ambiente_controlado(ambiente_controlado):
    resultado = ambiente_controlado.executar("entrada")
    assert resultado == "esperado"
```

### 8. ğŸ§± Teste de CÃ³digo Defensivo
```python
def test_[nome]_seguro_com_none_e_dados_invalidos():
    assert [classe]().processar(None) == VALOR_PADRAO
    with pytest.raises(ValueError):
        [classe]().processar("invÃ¡lido")
```

---

## ğŸ“Š MATRIZ DE COBERTURA (exemplo)
```json
{
  "module": "[nome_modulo]",
  "coverage": {
    "statements": "100%",
    "branches": "95%",
    "edge_cases": [
      "entrada_vazia", "valor_nulo", "limite_superior"
    ],
    "error_paths": [
      "input_malformado", "falha_externa_simulada"
    ]
  }
}
```

---

## ğŸš¦ CHECKLIST DE QUALIDADE

- [x] Caminhos positivos e negativos cobertos  
- [x] Todos os erros previstos testados  
- [x] Isolamento garantido via fixture  
- [x] Assertivas especÃ­ficas e claras  
- [x] Nenhuma dependÃªncia real  
- [x] Performance validada (se aplicÃ¡vel)  
- [x] Testes baseados em propriedades incluÃ­dos  
- [x] Interface contratual verificada (se aplicÃ¡vel)  

---

## ğŸ§  PADRÃ•ES ADICIONAIS

- Testes com nomeaÃ§Ã£o descritiva: `test_[unidade]_[comportamento]_[condicao]`
- Ambiente controlado com setup/teardown automatizado (fixtures)
- DocumentaÃ§Ã£o embarcada no prÃ³prio teste
- Cobertura com `coverage.py` ou `pytest-cov`
- Performance com `pytest-benchmark` se necessÃ¡rio

---

**Pronto para CI/CD e produÃ§Ã£o. Copie, adapte e aplique nos seus mÃ³dulos.**
