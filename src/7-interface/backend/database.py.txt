import os
import logging
import time
import redis
from sqlalchemy import create_engine, MetaData
from sqlalchemy.orm import sessionmaker, scoped_session
from sqlalchemy.exc import OperationalError
from dotenv import load_dotenv
import alembic.config
from prometheus_client import Gauge, start_http_server
import threading
import shutil
from datetime import datetime
import pytest

# üîÑ Carregar vari√°veis de ambiente
load_dotenv()

# üì¢ Configura√ß√£o de Logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
)

# üì¶ Configura√ß√£o do Banco de Dados
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///db.sqlite3")
POOL_SIZE = int(os.getenv("POOL_SIZE", 5))
MAX_OVERFLOW = int(os.getenv("MAX_OVERFLOW", 10))
TIMEOUT = int(os.getenv("DB_TIMEOUT", 10))
BACKUP_DIR = os.getenv("BACKUP_DIR", "./db_backups")

# üöÄ Criando Engine do Banco de Dados
engine = create_engine(
    DATABASE_URL,
    pool_size=POOL_SIZE,
    max_overflow=MAX_OVERFLOW,
    connect_args={"timeout": TIMEOUT} if "sqlite" in DATABASE_URL else {},
    echo=os.getenv("SQLALCHEMY_ECHO", "False") == "True",
)

SessionLocal = scoped_session(sessionmaker(autocommit=False, autoflush=False, bind=engine))
metadata = MetaData()

# üîÑ Configura√ß√£o de Cache (Redis)
CACHE_ENABLED = os.getenv("CACHE_ENABLED", "True") == "True"
if CACHE_ENABLED:
    redis_client = redis.Redis(host=os.getenv("REDIS_HOST", "localhost"), port=int(os.getenv("REDIS_PORT", 6379)), db=0)
    logging.info("‚ö° Redis ativado para cache de consultas frequentes.")

# üìä Monitoramento de Banco com Prometheus
DB_CONNECTIONS = Gauge("db_active_connections", "N√∫mero de conex√µes ativas com o banco")
DB_QUERY_TIME = Gauge("db_query_time", "Tempo de execu√ß√£o das queries")

start_http_server(8001)  # Exposi√ß√£o das m√©tricas no endpoint /metrics

def monitor_database():
    while True:
        try:
            with engine.connect() as conn:
                start_time = time.time()
                conn.execute("SELECT 1")
                query_time = time.time() - start_time
                DB_QUERY_TIME.set(query_time)
                DB_CONNECTIONS.set(engine.pool.status())
                logging.info(f"üìä Query time: {query_time:.4f}s - Conex√µes ativas: {engine.pool.status()}")
        except OperationalError as e:
            logging.error(f"‚ùå Erro ao monitorar o banco: {e}")
        time.sleep(10)

threading.Thread(target=monitor_database, daemon=True).start()

# üîÑ Fun√ß√£o para Testar Conex√£o com o Banco
def test_db_connection():
    retries = 5
    for attempt in range(retries):
        try:
            with engine.connect() as conn:
                conn.execute("SELECT 1")
                logging.info("‚úÖ Conex√£o com o banco de dados bem-sucedida!")
                return
        except OperationalError as e:
            logging.warning(f"‚ö†Ô∏è Falha na conex√£o ({attempt+1}/{retries}): {e}")
            time.sleep(2)
    logging.error("‚ùå N√£o foi poss√≠vel conectar ao banco de dados ap√≥s v√°rias tentativas!")

# üîÑ Fun√ß√£o para Aplicar Migra√ß√µes Alembic
def run_migrations():
    logging.info("üîÑ Executando migra√ß√µes do banco de dados...")
    alembic.config.main(["--raiseerr", "upgrade", "head"])

# üõ† Backup Autom√°tico do Banco de Dados
def backup_database():
    os.makedirs(BACKUP_DIR, exist_ok=True)
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_path = os.path.join(BACKUP_DIR, f"backup_{timestamp}.sqlite3")
    try:
        if "sqlite" in DATABASE_URL:
            shutil.copyfile(DATABASE_URL.replace("sqlite:///", ""), backup_path)
            logging.info(f"üì¶ Backup do banco criado: {backup_path}")
        else:
            logging.warning("‚ö†Ô∏è Backup autom√°tico s√≥ est√° configurado para SQLite no momento.")
    except Exception as e:
        logging.error(f"‚ùå Erro ao criar backup: {e}")

# üîÑ Inicializa√ß√£o do Banco de Dados
def init_db():
    test_db_connection()
    run_migrations()
    backup_database()
    logging.info("‚úÖ Banco de dados inicializado com sucesso!")

# üî¨ Testes Automatizados com `pytest`
@pytest.fixture
def db_session():
    return SessionLocal()

@pytest.mark.parametrize("query, expected", [
    ("SELECT 1", 1),
])
def test_database_queries(db_session, query, expected):
    result = db_session.execute(query).fetchone()
    assert result[0] == expected

if __name__ == "__main__":
    init_db()
